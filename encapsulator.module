<?php

use Drupal\Core\Entity\EntityInterface;
use Drupal\Core\File\FileSystemInterface;

function convertir_a_mp3($audio_origen, $audio_desti) {
	
	try {

		$ffmpeg = FFMpeg\FFMpeg::create();
		$audio = $ffmpeg->open($audio_origen);

		$format = new FFMpeg\Format\Audio\Mp3();
		$format->on('progress', function ($audio, $format, $percentage) {
			//\Drupal::logger('encapsulator')->notice('Progrés: ' . $percentage . '%');
		});

		$format
			->setAudioChannels(2)
			->setAudioKiloBitrate(192);

		$audio->save($format, $audio_desti);

		\Drupal::logger('encapsulator')->notice('Conversió completada, arxiu guardat a: ' . $audio_desti);

		return true;
		
	} catch(Exception $e) {
		\Drupal::logger('encapsulator')->error('Hi hagut un error en convertir a MP3 el següent fitxer: ' . $audio_origen . ' ' . $e->getMessage());
		return false;
	}
	
}

function unir_parts($audio_intro, $audio_locucio, $audio_outro, $audio_desti) {

	try {
		
		$ffmpeg = FFMpeg\FFMpeg::create();
		$video = $ffmpeg->open($audio_intro);
		$video
			->concat(array($audio_intro, $audio_locucio, $audio_outro))
			->saveFromSameCodecs($audio_desti, false);
		
		\Drupal::logger('encapsulator')->notice('Unió completada, arxiu guardat a: ' . $audio_desti);
		
		return true;
		
	} catch(Exception $e) {
		\Drupal::logger('encapsulator')->error('Hi hagut un error en unir els MP3 dels següents fitxers: ' . $audio_intro . ' + ' . $audio_locucio . ' + ' . $audio_outro . ' ' . $e->getMessage());
		return false;
	}
	
}

function validar_resultat($audio_a_validar) {

	try {
		
		$ffprobe = FFMpeg\FFProbe::create();
		return $ffprobe->isValid($audio_a_validar);
		
	} catch(Exception $e) {
		\Drupal::logger('encapsulator')->error('Hi hagut un error en validar el fitxer: ' . $audio_a_validar . ' ' . $e->getMessage());
		return false;
	}
	
}

/**
 * Implements hook_entity_presave().
 */
function encapsulator_entity_presave(EntityInterface $entity) {
		
	if ($entity->getEntityTypeId() == 'node') {
		
		switch ($entity->bundle()) {
			case 'capsula':
				
				//kint($entity->bundle());
				
				\Drupal::logger('encapsulator')->notice('INICI DEL PROCÉS!');
				
				
				//Constants per poder generar els paths del sistema on es troben els fitxers
				$path = '/home/locutor/encapsulador/';
				$prefix_private = 'private://';
				$tmp = \Drupal::service('file_system')->getTempDirectory() . '/';
				
				//Obtenim el camp on hi ha el fitxer de locució (veu del locutor)
				$locucio_id = $entity->get('field_capsula_locucio')->getValue()[0]['target_id'];
				
				//Obtenim l'objecte que representa la locució
				$file_locucio = \Drupal::entityTypeManager()->getStorage('file')->load($locucio_id);
				
				$locucio_path_relative = ltrim($file_locucio->getFileUri(), $prefix_private);
				$locucio_path_absolute = $path . $locucio_path_relative;
				
				//kint($locucio_path_absolute);
				
				

				//Obtenim el camp on hi ha el terme de taxonomia
				//kint($entity->get('field_capsula_tipus_de_capsula')->getValue()[0]['target_id']);
				$intro_term_id = $entity->get('field_capsula_tipus_de_capsula')->getValue()[0]['target_id'];
				$intro_term = \Drupal\taxonomy\Entity\Term::load($intro_term_id);
				//kint($intro_term);
				
				//Obtenim el camp on hi ha el fitxer d'audio d'intro (que es troba com a camp en el terme de taxonomia)
				//kint($intro_term->get('field_tipus_de_capsula_audio')->getValue()[0]['target_id']);
				$intro_id = $intro_term->get('field_tipus_de_capsula_audio')->getValue()[0]['target_id'];
				
				//Obtenin l'objecte que representa l'audio de l'intro
				$file_intro = \Drupal::entityTypeManager()->getStorage('file')->load($intro_id);
				$intro_path_relative = str_replace($prefix_private, '', $file_intro->getFileUri());
				$intro_path_absolute = $path . $intro_path_relative;
				
				//kint($intro_path_absolute);
					
				
				
				//Obtenim el camp on hi ha el terme de taxonomia
				//kint($entity->get('field_capsula_tipus_de_final')->getValue()[0]['target_id']);
				$outro_term_id = $entity->get('field_capsula_tipus_de_final')->getValue()[0]['target_id'];
				$outro_term = \Drupal\taxonomy\Entity\Term::load($outro_term_id);
				//kint($outro_term);
				
				//Obtenim el camp on hi ha el fitxer d'audio d'outro (que es troba com a camp en el terme de taxonomia)
				//kint($outro_term->get('field_tipus_de_final_audio')->getValue()[0]['target_id']);
				$outro_id = $outro_term->get('field_tipus_de_final_audio')->getValue()[0]['target_id'];
				
				//Obtenin l'objecte que representa l'audio de l'outro
				$file_outro = \Drupal::entityTypeManager()->getStorage('file')->load($outro_id);
				$outro_path_relative = str_replace($prefix_private, '', $file_outro->getFileUri());
				$outro_path_absolute = $path . $outro_path_relative;
				
				//kint($outro_path_absolute);

				
				//Ara que ja tenim els 3 fitxers d'àudio necessaris els processarem amb la llibreria FFMpeg
				$resultat_final = true;
				
				//Generem els directoris temporals de les parts
				$uuid = \Drupal::service('uuid');
				$uuid_tmp = $uuid->generate();
				$intro_path_tmp = $tmp . $uuid_tmp . '_intro.mp3';
				$locucio_path_tmp = $tmp . $uuid_tmp . '_locucio.mp3';
				$outro_path_tmp = $tmp . $uuid_tmp . '_outro.mp3';
				$resultat_tmp = $tmp . $uuid_tmp . '_resultat.mp3'; //'/var/www/html/encapsulador/web/modules/custom/encapsulator/units.mp3'
				
				//Convertim/codifiquem els 3 fitxers en MP3
				$resultat1 = convertir_a_mp3($intro_path_absolute, $intro_path_tmp);
				$resultat2 = convertir_a_mp3($locucio_path_absolute, $locucio_path_tmp);
				$resultat3 = convertir_a_mp3($outro_path_absolute, $outro_path_tmp);
				
				if ($resultat1 && $resultat2 && $resultat3) {
					
					//Unim els 3 fitxers en un de sol
					$resultat_unir = unir_parts($intro_path_tmp, $locucio_path_tmp, $outro_path_tmp, $resultat_tmp);
					
					if ($resultat_unir) {
						
						//Validem que el fitxer resultant s'ha generat correctament
						if (validar_resultat($resultat_tmp)) {
							\Drupal::logger('encapsulator')->notice('FI DEL PROCÉS CORRECTE!');
						} else {
							$resultat_final = false;
						}
						
					} else {
						$resultat_final = false;
					}
					
				} else {
					$resultat_final = false;
				}
				
				if (!$resultat_final) {
					\Drupal::logger('encapsulator')->error('FI DEL PROCÉS INCORRECTE!');
				}
				
				//Guardem el fitxer de la capsula resultant final en el camp del node
				$handle = fopen($resultat_tmp, 'r');
				$fileRepository = \Drupal::service('file.repository');
				$file = $fileRepository->writeData(fread($handle, filesize($resultat_tmp)), $prefix_private . 'resultat.mp3', FileSystemInterface::EXISTS_REPLACE);
				fclose($handle);
				
				//Un cop guardat el fitxer al directori final i creada la seva entitat dins del sistema Drupal, el vincularem l'entitat/node que toqui
				//$entity_storage = \Drupal::entityTypeManager()->getStorage('node');
				//$entity = $entity_storage->load(1);
				$entity->set('field_capsula_generada', $file);
				//$entity->save(); //Si cridem aquesta funció dins del hook_entity_presave() generarem una crida recursiva en aquest hook que no acabarà mai
				
				\Drupal::logger('encapsulator')->notice('### PROCÉS COMPLETAT COMPLETAMENT ###');

				
				// 1 - Treure silencis (davant i darrera)
				// 2 - Unir els 3 fitxers
				// 3 - Normalitzar el fitxer
				// 4 - Guardar-ho en el camp del node on es guarda la càpsula generada
				
				// 5 - Sync/copiar a directori que poden emetre (segons les dates d'inici i fi)
				// 6 - Eliminar del directori que es poden emetre si la data ha vençut
				
				
				
				break;
		}
		
	}
	
	return $entity;
	
}


/**
 * Implements hook_cron().
 */
function encapsulator_cron() {
	
	//Obtenim tots els identificadors de fitxers
	$fids = Drupal::entityQuery('file')->execute();
	
	//Obtenim el servei que ens ajudarà a determinar si cada fitxer està en ús o bé està orfe
	$file_usage = Drupal::service('file.usage');
	
	//Recorrem tots els fitxers per la seva fid (identificador de fitxer)
  	foreach ($fids as $fid) {
	
	//A partir del fid obtenim l'entitat del fitxer
    $file = Drupal\file\Entity\File::load($fid);
	
	//Obtenim l'atribut del fitxer que ens indicarà si el fitxer està essent usat per alguna entitat/node
    $usage = $file_usage->listUsage($file);
	  
    //Si el valor = 0, significarà que no està essent usant i que per tant es pot eliminar
    if (count($usage) == 0) {
		
		//Eliminem el fitxer
		$file->delete();
		
    }
	  
  }
	
}